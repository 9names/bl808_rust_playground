/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[doc = "  @brief Serial flash configuration structure type definition"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SPI_Flash_Cfg_Type {
    #[doc = "< Serail flash interface mode,bit0-3:IF mode,bit4:unwrap,bit5:32-bits addr mode support"]
    pub ioMode: u8,
    #[doc = "< Support continuous read mode,bit0:continuous read mode support,bit1:read mode cfg"]
    pub cReadSupport: u8,
    #[doc = "< SPI clock delay,bit0-3:delay,bit4-6:pad delay"]
    pub clkDelay: u8,
    #[doc = "< SPI clock phase invert,bit0:clck invert,bit1:rx invert,bit2-4:pad delay,bit5-7:pad delay"]
    pub clkInvert: u8,
    #[doc = "< Flash enable reset command"]
    pub resetEnCmd: u8,
    #[doc = "< Flash reset command"]
    pub resetCmd: u8,
    #[doc = "< Flash reset continuous read command"]
    pub resetCreadCmd: u8,
    #[doc = "< Flash reset continuous read command size"]
    pub resetCreadCmdSize: u8,
    #[doc = "< JEDEC ID command"]
    pub jedecIdCmd: u8,
    #[doc = "< JEDEC ID command dummy clock"]
    pub jedecIdCmdDmyClk: u8,
    #[doc = "< Enter 32-bits addr command"]
    pub enter32BitsAddrCmd: u8,
    #[doc = "< Exit 32-bits addr command"]
    pub exit32BitsAddrCmd: u8,
    #[doc = "< *1024bytes"]
    pub sectorSize: u8,
    #[doc = "< Manufacturer ID"]
    pub mid: u8,
    #[doc = "< Page size"]
    pub pageSize: u16,
    #[doc = "< Chip erase cmd"]
    pub chipEraseCmd: u8,
    #[doc = "< Sector erase command"]
    pub sectorEraseCmd: u8,
    #[doc = "< Block 32K erase command,some Micron not support"]
    pub blk32EraseCmd: u8,
    #[doc = "< Block 64K erase command"]
    pub blk64EraseCmd: u8,
    #[doc = "< Need before every erase or program"]
    pub writeEnableCmd: u8,
    #[doc = "< Page program cmd"]
    pub pageProgramCmd: u8,
    #[doc = "< QIO page program cmd"]
    pub qpageProgramCmd: u8,
    #[doc = "< QIO page program address mode"]
    pub qppAddrMode: u8,
    #[doc = "< Fast read command"]
    pub fastReadCmd: u8,
    #[doc = "< Fast read command dummy clock"]
    pub frDmyClk: u8,
    #[doc = "< QPI fast read command"]
    pub qpiFastReadCmd: u8,
    #[doc = "< QPI fast read command dummy clock"]
    pub qpiFrDmyClk: u8,
    #[doc = "< Fast read dual output command"]
    pub fastReadDoCmd: u8,
    #[doc = "< Fast read dual output command dummy clock"]
    pub frDoDmyClk: u8,
    #[doc = "< Fast read dual io comamnd"]
    pub fastReadDioCmd: u8,
    #[doc = "< Fast read dual io command dummy clock"]
    pub frDioDmyClk: u8,
    #[doc = "< Fast read quad output comamnd"]
    pub fastReadQoCmd: u8,
    #[doc = "< Fast read quad output comamnd dummy clock"]
    pub frQoDmyClk: u8,
    #[doc = "< Fast read quad io comamnd"]
    pub fastReadQioCmd: u8,
    #[doc = "< Fast read quad io comamnd dummy clock"]
    pub frQioDmyClk: u8,
    #[doc = "< QPI fast read quad io comamnd"]
    pub qpiFastReadQioCmd: u8,
    #[doc = "< QPI fast read QIO dummy clock"]
    pub qpiFrQioDmyClk: u8,
    #[doc = "< QPI program command"]
    pub qpiPageProgramCmd: u8,
    #[doc = "< Enable write reg"]
    pub writeVregEnableCmd: u8,
    #[doc = "< Write enable register index"]
    pub wrEnableIndex: u8,
    #[doc = "< Quad mode enable register index"]
    pub qeIndex: u8,
    #[doc = "< Busy status register index"]
    pub busyIndex: u8,
    #[doc = "< Write enable bit pos"]
    pub wrEnableBit: u8,
    #[doc = "< Quad enable bit pos"]
    pub qeBit: u8,
    #[doc = "< Busy status bit pos"]
    pub busyBit: u8,
    #[doc = "< Register length of write enable"]
    pub wrEnableWriteRegLen: u8,
    #[doc = "< Register length of write enable status"]
    pub wrEnableReadRegLen: u8,
    #[doc = "< Register length of contain quad enable"]
    pub qeWriteRegLen: u8,
    #[doc = "< Register length of contain quad enable status"]
    pub qeReadRegLen: u8,
    #[doc = "< Release power down command"]
    pub releasePowerDown: u8,
    #[doc = "< Register length of contain busy status"]
    pub busyReadRegLen: u8,
    #[doc = "< Read register command buffer"]
    pub readRegCmd: [u8; 4usize],
    #[doc = "< Write register command buffer"]
    pub writeRegCmd: [u8; 4usize],
    #[doc = "< Enter qpi command"]
    pub enterQpi: u8,
    #[doc = "< Exit qpi command"]
    pub exitQpi: u8,
    #[doc = "< Config data for continuous read mode"]
    pub cReadMode: u8,
    #[doc = "< Config data for exit continuous read mode"]
    pub cRExit: u8,
    #[doc = "< Enable burst wrap command"]
    pub burstWrapCmd: u8,
    #[doc = "< Enable burst wrap command dummy clock"]
    pub burstWrapCmdDmyClk: u8,
    #[doc = "< Data and address mode for this command"]
    pub burstWrapDataMode: u8,
    #[doc = "< Data to enable burst wrap"]
    pub burstWrapData: u8,
    #[doc = "< Disable burst wrap command"]
    pub deBurstWrapCmd: u8,
    #[doc = "< Disable burst wrap command dummy clock"]
    pub deBurstWrapCmdDmyClk: u8,
    #[doc = "< Data and address mode for this command"]
    pub deBurstWrapDataMode: u8,
    #[doc = "< Data to disable burst wrap"]
    pub deBurstWrapData: u8,
    #[doc = "< 4K erase time"]
    pub timeEsector: u16,
    #[doc = "< 32K erase time"]
    pub timeE32k: u16,
    #[doc = "< 64K erase time"]
    pub timeE64k: u16,
    #[doc = "< Page program time"]
    pub timePagePgm: u16,
    #[doc = "< Chip erase time in ms"]
    pub timeCe: u16,
    #[doc = "< Release power down command delay time for wake up"]
    pub pdDelay: u8,
    #[doc = "< QE set data"]
    pub qeData: u8,
}
#[test]
fn bindgen_test_layout_SPI_Flash_Cfg_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SPI_Flash_Cfg_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SPI_Flash_Cfg_Type>(),
        84usize,
        concat!("Size of: ", stringify!(SPI_Flash_Cfg_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SPI_Flash_Cfg_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SPI_Flash_Cfg_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ioMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(ioMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cReadSupport) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(cReadSupport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clkDelay) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(clkDelay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clkInvert) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(clkInvert)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resetEnCmd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(resetEnCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resetCmd) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(resetCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resetCreadCmd) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(resetCreadCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resetCreadCmdSize) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(resetCreadCmdSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jedecIdCmd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(jedecIdCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jedecIdCmdDmyClk) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(jedecIdCmdDmyClk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enter32BitsAddrCmd) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(enter32BitsAddrCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exit32BitsAddrCmd) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(exit32BitsAddrCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sectorSize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(sectorSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mid) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(mid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pageSize) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(pageSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chipEraseCmd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(chipEraseCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sectorEraseCmd) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(sectorEraseCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blk32EraseCmd) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(blk32EraseCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blk64EraseCmd) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(blk64EraseCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writeEnableCmd) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(writeEnableCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pageProgramCmd) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(pageProgramCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qpageProgramCmd) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(qpageProgramCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qppAddrMode) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(qppAddrMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fastReadCmd) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(fastReadCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frDmyClk) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(frDmyClk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qpiFastReadCmd) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(qpiFastReadCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qpiFrDmyClk) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(qpiFrDmyClk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fastReadDoCmd) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(fastReadDoCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frDoDmyClk) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(frDoDmyClk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fastReadDioCmd) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(fastReadDioCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frDioDmyClk) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(frDioDmyClk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fastReadQoCmd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(fastReadQoCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frQoDmyClk) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(frQoDmyClk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fastReadQioCmd) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(fastReadQioCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frQioDmyClk) as usize - ptr as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(frQioDmyClk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qpiFastReadQioCmd) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(qpiFastReadQioCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qpiFrQioDmyClk) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(qpiFrQioDmyClk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qpiPageProgramCmd) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(qpiPageProgramCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writeVregEnableCmd) as usize - ptr as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(writeVregEnableCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wrEnableIndex) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(wrEnableIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qeIndex) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(qeIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).busyIndex) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(busyIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wrEnableBit) as usize - ptr as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(wrEnableBit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qeBit) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(qeBit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).busyBit) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(busyBit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wrEnableWriteRegLen) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(wrEnableWriteRegLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wrEnableReadRegLen) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(wrEnableReadRegLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qeWriteRegLen) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(qeWriteRegLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qeReadRegLen) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(qeReadRegLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).releasePowerDown) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(releasePowerDown)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).busyReadRegLen) as usize - ptr as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(busyReadRegLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).readRegCmd) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(readRegCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writeRegCmd) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(writeRegCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enterQpi) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(enterQpi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exitQpi) as usize - ptr as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(exitQpi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cReadMode) as usize - ptr as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(cReadMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cRExit) as usize - ptr as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(cRExit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).burstWrapCmd) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(burstWrapCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).burstWrapCmdDmyClk) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(burstWrapCmdDmyClk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).burstWrapDataMode) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(burstWrapDataMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).burstWrapData) as usize - ptr as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(burstWrapData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deBurstWrapCmd) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(deBurstWrapCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deBurstWrapCmdDmyClk) as usize - ptr as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(deBurstWrapCmdDmyClk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deBurstWrapDataMode) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(deBurstWrapDataMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deBurstWrapData) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(deBurstWrapData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeEsector) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(timeEsector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeE32k) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(timeE32k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeE64k) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(timeE64k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timePagePgm) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(timePagePgm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeCe) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(timeCe)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdDelay) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(pdDelay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qeData) as usize - ptr as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_Flash_Cfg_Type),
            "::",
            stringify!(qeData)
        )
    );
}
#[doc = "  @brief Serial flash security register configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SFlash_Sec_Reg_Cfg {
    #[doc = "< Erase security register command"]
    pub eraseCmd: u8,
    #[doc = "< Program security register command"]
    pub programCmd: u8,
    #[doc = "< Read security register command"]
    pub readCmd: u8,
    #[doc = "< Enter security register option mode command"]
    pub enterSecOptCmd: u8,
    #[doc = "< Exit security register option mode command"]
    pub exitSecOptCmd: u8,
    #[doc = "< Security register block number"]
    pub blockNum: u8,
    #[doc = "< Data pointer to be program/read"]
    pub data: *mut u8,
    #[doc = "< Start address to be program/read"]
    pub addr: u32,
    #[doc = "< Data length to be program/read"]
    pub len: u32,
}
#[test]
fn bindgen_test_layout_SFlash_Sec_Reg_Cfg() {
    const UNINIT: ::core::mem::MaybeUninit<SFlash_Sec_Reg_Cfg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SFlash_Sec_Reg_Cfg>(),
        20usize,
        concat!("Size of: ", stringify!(SFlash_Sec_Reg_Cfg))
    );
    assert_eq!(
        ::core::mem::align_of::<SFlash_Sec_Reg_Cfg>(),
        4usize,
        concat!("Alignment of ", stringify!(SFlash_Sec_Reg_Cfg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eraseCmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SFlash_Sec_Reg_Cfg),
            "::",
            stringify!(eraseCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).programCmd) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SFlash_Sec_Reg_Cfg),
            "::",
            stringify!(programCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).readCmd) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SFlash_Sec_Reg_Cfg),
            "::",
            stringify!(readCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enterSecOptCmd) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SFlash_Sec_Reg_Cfg),
            "::",
            stringify!(enterSecOptCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exitSecOptCmd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SFlash_Sec_Reg_Cfg),
            "::",
            stringify!(exitSecOptCmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blockNum) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(SFlash_Sec_Reg_Cfg),
            "::",
            stringify!(blockNum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SFlash_Sec_Reg_Cfg),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SFlash_Sec_Reg_Cfg),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SFlash_Sec_Reg_Cfg),
            "::",
            stringify!(len)
        )
    );
}
#[repr(u32)]
#[doc = "  @brief PDS GPIO int set type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PDS_GPIO_INT_SET_Type {
    #[doc = "< gpio int set 1, gpio0 - gpio7"]
    PDS_GPIO_INT_SET_1_GPIO0_GPIO7 = 0,
    #[doc = "< gpio int set 2, gpio8, gpio16 - gpio22"]
    PDS_GPIO_INT_SET_2_GPIO8_16_GPIO22 = 1,
    #[doc = "< gpio int set 3, gpio23 - gpio30"]
    PDS_GPIO_INT_SET_3_GPIO23_GPIO30 = 2,
    #[doc = "< gpio int set 4, gpio31 - gpio38"]
    PDS_GPIO_INT_SET_4_GPIO31_GPIO38 = 3,
}
#[repr(u32)]
#[doc = "  @brief PDS GPIO interrupt control mode type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PDS_GPIO_INT_TRIG_Type {
    #[doc = "< GPIO interrupt sync mode, GPIO negedge pulse trigger interrupt"]
    PDS_GPIO_INT_SYNC_FALLING_EDGE = 0,
    #[doc = "< GPIO interrupt sync mode, GPIO posedge pulse trigger interrupt"]
    PDS_GPIO_INT_SYNC_RISING_EDGE = 1,
    #[doc = "< GPIO interrupt sync mode, GPIO negedge level trigger interrupt"]
    PDS_GPIO_INT_SYNC_LOW_LEVEL = 2,
    #[doc = "< GPIO interrupt sync mode, GPIO posedge level trigger interrupt"]
    PDS_GPIO_INT_SYNC_HIGH_LEVEL = 3,
    #[doc = "< GPIO interrupt sync mode, GPIO posedge negedge pulse trigger interrupt"]
    PDS_GPIO_INT_SYNC_RISING_FALLING_EDGE = 4,
    #[doc = "< GPIO interrupt async mode, GPIO negedge pulse trigger interrupt"]
    PDS_GPIO_INT_ASYNC_FALLING_EDGE = 8,
    #[doc = "< GPIO interrupt async mode, GPIO posedge pulse trigger interrupt"]
    PDS_GPIO_INT_ASYNC_RISING_EDGE = 9,
    #[doc = "< GPIO interrupt async mode, GPIO negedge level trigger interrupt"]
    PDS_GPIO_INT_ASYNC_LOW_LEVEL = 10,
    #[doc = "< GPIO interrupt async mode, GPIO posedge level trigger interrupt"]
    PDS_GPIO_INT_ASYNC_HIGH_LEVEL = 11,
}
#[repr(u32)]
#[doc = "  @brief PDS lp system clock type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PDS_LP_SYS_CLK_Type {
    #[doc = "< use bclk div as system clock frequency"]
    PDS_LP_SYS_CLK_BCLK_DIV = 0,
}
#[repr(u32)]
#[doc = "  @brief PDS LDO level type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PDS_LDO_LEVEL_Type {
    #[doc = "< PDS LDO voltage 0.70V"]
    PDS_LDO_LEVEL_0P70V = 2,
    #[doc = "< PDS LDO voltage 0.75V"]
    PDS_LDO_LEVEL_0P75V = 3,
    #[doc = "< PDS LDO voltage 0.80V"]
    PDS_LDO_LEVEL_0P80V = 4,
    #[doc = "< PDS LDO voltage 0.85V"]
    PDS_LDO_LEVEL_0P85V = 5,
    #[doc = "< PDS LDO voltage 0.90V"]
    PDS_LDO_LEVEL_0P90V = 6,
    #[doc = "< PDS LDO voltage 0.95V"]
    PDS_LDO_LEVEL_0P95V = 7,
    #[doc = "< PDS LDO voltage 1.00V"]
    PDS_LDO_LEVEL_1P00V = 8,
    #[doc = "< PDS LDO voltage 1.05V"]
    PDS_LDO_LEVEL_1P05V = 9,
    #[doc = "< PDS LDO voltage 1.10V"]
    PDS_LDO_LEVEL_1P10V = 10,
    #[doc = "< PDS LDO voltage 1.15V"]
    PDS_LDO_LEVEL_1P15V = 11,
    #[doc = "< PDS LDO voltage 1.20V"]
    PDS_LDO_LEVEL_1P20V = 12,
    #[doc = "< PDS LDO voltage 1.25V"]
    PDS_LDO_LEVEL_1P25V = 13,
    #[doc = "< PDS LDO voltage 1.30V"]
    PDS_LDO_LEVEL_1P30V = 14,
    #[doc = "< PDS LDO voltage 1.35V"]
    PDS_LDO_LEVEL_1P35V = 15,
}
#[doc = "  @brief PDS configuration type definition"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PDS_CTL_Type {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PDS_CTL_Type() {
    assert_eq!(
        ::core::mem::size_of::<PDS_CTL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PDS_CTL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PDS_CTL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PDS_CTL_Type))
    );
}
impl PDS_CTL_Type {
    #[inline]
    pub fn pdsStart(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdsStart(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sleepForever(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sleepForever(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtalForceOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtalForceOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn saveWiFiState(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_saveWiFiState(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dcdc11Off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dcdc11Off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bgSysOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bgSysOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ctrlGpioIePuPd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctrlGpioIePuPd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dcdc18Off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dcdc18Off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clkOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clkOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memStby(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memStby(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn glbRstProtect(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_glbRstProtect(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isolation(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isolation(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn waitXtalRdy(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_waitXtalRdy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdsPwrOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdsPwrOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xtalOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xtalOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn socEnbForceOn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_socEnbForceOn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdsRstSocEn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdsRstSocEn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdsRC32mOn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdsRC32mOn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdsDcdc11VselEn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdsDcdc11VselEn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usbpllOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usbpllOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aupllOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aupllOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cpupllOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cpupllOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifipllOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wifipllOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdsDcdc11Vsel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_pdsDcdc11Vsel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn pdsCtlRfSel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pdsCtlRfSel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pdsUseTbttSlp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdsUseTbttSlp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdsGpioIsoMod(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdsGpioIsoMod(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pdsStart: u32,
        sleepForever: u32,
        xtalForceOff: u32,
        saveWiFiState: u32,
        dcdc11Off: u32,
        bgSysOff: u32,
        ctrlGpioIePuPd: u32,
        dcdc18Off: u32,
        clkOff: u32,
        memStby: u32,
        glbRstProtect: u32,
        isolation: u32,
        waitXtalRdy: u32,
        pdsPwrOff: u32,
        xtalOff: u32,
        socEnbForceOn: u32,
        pdsRstSocEn: u32,
        pdsRC32mOn: u32,
        pdsDcdc11VselEn: u32,
        usbpllOff: u32,
        aupllOff: u32,
        cpupllOff: u32,
        wifipllOff: u32,
        pdsDcdc11Vsel: u32,
        pdsCtlRfSel: u32,
        pdsUseTbttSlp: u32,
        pdsGpioIsoMod: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pdsStart: u32 = unsafe { ::core::mem::transmute(pdsStart) };
            pdsStart as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sleepForever: u32 = unsafe { ::core::mem::transmute(sleepForever) };
            sleepForever as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let xtalForceOff: u32 = unsafe { ::core::mem::transmute(xtalForceOff) };
            xtalForceOff as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let saveWiFiState: u32 = unsafe { ::core::mem::transmute(saveWiFiState) };
            saveWiFiState as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dcdc11Off: u32 = unsafe { ::core::mem::transmute(dcdc11Off) };
            dcdc11Off as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bgSysOff: u32 = unsafe { ::core::mem::transmute(bgSysOff) };
            bgSysOff as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ctrlGpioIePuPd: u32 = unsafe { ::core::mem::transmute(ctrlGpioIePuPd) };
            ctrlGpioIePuPd as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dcdc18Off: u32 = unsafe { ::core::mem::transmute(dcdc18Off) };
            dcdc18Off as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let clkOff: u32 = unsafe { ::core::mem::transmute(clkOff) };
            clkOff as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let memStby: u32 = unsafe { ::core::mem::transmute(memStby) };
            memStby as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let glbRstProtect: u32 = unsafe { ::core::mem::transmute(glbRstProtect) };
            glbRstProtect as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let isolation: u32 = unsafe { ::core::mem::transmute(isolation) };
            isolation as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let waitXtalRdy: u32 = unsafe { ::core::mem::transmute(waitXtalRdy) };
            waitXtalRdy as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let pdsPwrOff: u32 = unsafe { ::core::mem::transmute(pdsPwrOff) };
            pdsPwrOff as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let xtalOff: u32 = unsafe { ::core::mem::transmute(xtalOff) };
            xtalOff as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let socEnbForceOn: u32 = unsafe { ::core::mem::transmute(socEnbForceOn) };
            socEnbForceOn as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let pdsRstSocEn: u32 = unsafe { ::core::mem::transmute(pdsRstSocEn) };
            pdsRstSocEn as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let pdsRC32mOn: u32 = unsafe { ::core::mem::transmute(pdsRC32mOn) };
            pdsRC32mOn as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let pdsDcdc11VselEn: u32 = unsafe { ::core::mem::transmute(pdsDcdc11VselEn) };
            pdsDcdc11VselEn as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let usbpllOff: u32 = unsafe { ::core::mem::transmute(usbpllOff) };
            usbpllOff as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let aupllOff: u32 = unsafe { ::core::mem::transmute(aupllOff) };
            aupllOff as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let cpupllOff: u32 = unsafe { ::core::mem::transmute(cpupllOff) };
            cpupllOff as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let wifipllOff: u32 = unsafe { ::core::mem::transmute(wifipllOff) };
            wifipllOff as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let pdsDcdc11Vsel: u32 = unsafe { ::core::mem::transmute(pdsDcdc11Vsel) };
            pdsDcdc11Vsel as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let pdsCtlRfSel: u32 = unsafe { ::core::mem::transmute(pdsCtlRfSel) };
            pdsCtlRfSel as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let pdsUseTbttSlp: u32 = unsafe { ::core::mem::transmute(pdsUseTbttSlp) };
            pdsUseTbttSlp as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let pdsGpioIsoMod: u32 = unsafe { ::core::mem::transmute(pdsGpioIsoMod) };
            pdsGpioIsoMod as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "  @brief PDS force configuration type definition"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PDS_CTL4_Type {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PDS_CTL4_Type() {
    assert_eq!(
        ::core::mem::size_of::<PDS_CTL4_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PDS_CTL4_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PDS_CTL4_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PDS_CTL4_Type))
    );
}
impl PDS_CTL4_Type {
    #[inline]
    pub fn rsv0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsv0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcuRst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mcuRst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcuMemStby(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mcuMemStby(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcuGateClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mcuGateClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv4_7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rsv4_7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn dspPwrOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dspPwrOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dspRst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dspRst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dspMemStby(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dspMemStby(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dspGateClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dspGateClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsv12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WbRst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WbRst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WbMemStby(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WbMemStby(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WbGateClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WbGateClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv16_19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rsv16_19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn usbPwrOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usbPwrOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usbRst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usbRst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usbMemStby(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usbMemStby(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usbGateClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usbGateClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MiscPwrOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MiscPwrOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MiscRst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MiscRst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MiscMemStby(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MiscMemStby(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MiscGateClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MiscGateClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv28_31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rsv28_31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rsv0: u32,
        mcuRst: u32,
        mcuMemStby: u32,
        mcuGateClk: u32,
        rsv4_7: u32,
        dspPwrOff: u32,
        dspRst: u32,
        dspMemStby: u32,
        dspGateClk: u32,
        rsv12: u32,
        WbRst: u32,
        WbMemStby: u32,
        WbGateClk: u32,
        rsv16_19: u32,
        usbPwrOff: u32,
        usbRst: u32,
        usbMemStby: u32,
        usbGateClk: u32,
        MiscPwrOff: u32,
        MiscRst: u32,
        MiscMemStby: u32,
        MiscGateClk: u32,
        rsv28_31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rsv0: u32 = unsafe { ::core::mem::transmute(rsv0) };
            rsv0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mcuRst: u32 = unsafe { ::core::mem::transmute(mcuRst) };
            mcuRst as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mcuMemStby: u32 = unsafe { ::core::mem::transmute(mcuMemStby) };
            mcuMemStby as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mcuGateClk: u32 = unsafe { ::core::mem::transmute(mcuGateClk) };
            mcuGateClk as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let rsv4_7: u32 = unsafe { ::core::mem::transmute(rsv4_7) };
            rsv4_7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dspPwrOff: u32 = unsafe { ::core::mem::transmute(dspPwrOff) };
            dspPwrOff as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dspRst: u32 = unsafe { ::core::mem::transmute(dspRst) };
            dspRst as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let dspMemStby: u32 = unsafe { ::core::mem::transmute(dspMemStby) };
            dspMemStby as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let dspGateClk: u32 = unsafe { ::core::mem::transmute(dspGateClk) };
            dspGateClk as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rsv12: u32 = unsafe { ::core::mem::transmute(rsv12) };
            rsv12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let WbRst: u32 = unsafe { ::core::mem::transmute(WbRst) };
            WbRst as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let WbMemStby: u32 = unsafe { ::core::mem::transmute(WbMemStby) };
            WbMemStby as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let WbGateClk: u32 = unsafe { ::core::mem::transmute(WbGateClk) };
            WbGateClk as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let rsv16_19: u32 = unsafe { ::core::mem::transmute(rsv16_19) };
            rsv16_19 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let usbPwrOff: u32 = unsafe { ::core::mem::transmute(usbPwrOff) };
            usbPwrOff as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let usbRst: u32 = unsafe { ::core::mem::transmute(usbRst) };
            usbRst as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let usbMemStby: u32 = unsafe { ::core::mem::transmute(usbMemStby) };
            usbMemStby as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let usbGateClk: u32 = unsafe { ::core::mem::transmute(usbGateClk) };
            usbGateClk as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let MiscPwrOff: u32 = unsafe { ::core::mem::transmute(MiscPwrOff) };
            MiscPwrOff as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let MiscRst: u32 = unsafe { ::core::mem::transmute(MiscRst) };
            MiscRst as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let MiscMemStby: u32 = unsafe { ::core::mem::transmute(MiscMemStby) };
            MiscMemStby as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let MiscGateClk: u32 = unsafe { ::core::mem::transmute(MiscGateClk) };
            MiscGateClk as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let rsv28_31: u32 = unsafe { ::core::mem::transmute(rsv28_31) };
            rsv28_31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(u32)]
#[doc = "  @brief PDS interrupt type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PDS_INT_Type {
    #[doc = "< PDS wakeup interrupt(assert bit while wakeup, include PDS_Timer/...)"]
    PDS_INT_WAKEUP = 0,
    #[doc = "< PDS RF done interrupt"]
    PDS_INT_RF_DONE = 1,
    #[doc = "< PDS wifi tbtt sleep interrupt"]
    PDS_INT_WIFI_TBTT_SLEEP = 2,
    #[doc = "< PDS wifi tbtt wakeup interrupt"]
    PDS_INT_WIFI_TBTT_WAKEUP = 3,
    #[doc = "< PDS int max number"]
    PDS_INT_MAX = 4,
}
#[doc = "  @brief PDS force configuration type definition"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PDS_CTL2_Type {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PDS_CTL2_Type() {
    assert_eq!(
        ::core::mem::size_of::<PDS_CTL2_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PDS_CTL2_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PDS_CTL2_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PDS_CTL2_Type))
    );
}
impl PDS_CTL2_Type {
    #[inline]
    pub fn rsv0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsv0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceDspPwrOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceDspPwrOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsv2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceUsbPwrOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceUsbPwrOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsv4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceDspIso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceDspIso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsv6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceUsbIso(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceUsbIso(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceMcuPdsRst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceMcuPdsRst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceDspPdsRst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceDspPdsRst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceWbPdsRst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceWbPdsRst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceUsbPdsRst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceUsbPdsRst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceMcuMemStby(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceMcuMemStby(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceDspMemStby(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceDspMemStby(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceWbMemStby(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceWbMemStby(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceUsbMemStby(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceUsbMemStby(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceMcuGateClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceMcuGateClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceDspGateClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceDspGateClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceWbGateClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceWbGateClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceUsbGateClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceUsbGateClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv20_31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_rsv20_31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rsv0: u32,
        forceDspPwrOff: u32,
        rsv2: u32,
        forceUsbPwrOff: u32,
        rsv4: u32,
        forceDspIso: u32,
        rsv6: u32,
        forceUsbIso: u32,
        forceMcuPdsRst: u32,
        forceDspPdsRst: u32,
        forceWbPdsRst: u32,
        forceUsbPdsRst: u32,
        forceMcuMemStby: u32,
        forceDspMemStby: u32,
        forceWbMemStby: u32,
        forceUsbMemStby: u32,
        forceMcuGateClk: u32,
        forceDspGateClk: u32,
        forceWbGateClk: u32,
        forceUsbGateClk: u32,
        rsv20_31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rsv0: u32 = unsafe { ::core::mem::transmute(rsv0) };
            rsv0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let forceDspPwrOff: u32 = unsafe { ::core::mem::transmute(forceDspPwrOff) };
            forceDspPwrOff as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rsv2: u32 = unsafe { ::core::mem::transmute(rsv2) };
            rsv2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let forceUsbPwrOff: u32 = unsafe { ::core::mem::transmute(forceUsbPwrOff) };
            forceUsbPwrOff as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rsv4: u32 = unsafe { ::core::mem::transmute(rsv4) };
            rsv4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let forceDspIso: u32 = unsafe { ::core::mem::transmute(forceDspIso) };
            forceDspIso as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rsv6: u32 = unsafe { ::core::mem::transmute(rsv6) };
            rsv6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let forceUsbIso: u32 = unsafe { ::core::mem::transmute(forceUsbIso) };
            forceUsbIso as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let forceMcuPdsRst: u32 = unsafe { ::core::mem::transmute(forceMcuPdsRst) };
            forceMcuPdsRst as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let forceDspPdsRst: u32 = unsafe { ::core::mem::transmute(forceDspPdsRst) };
            forceDspPdsRst as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let forceWbPdsRst: u32 = unsafe { ::core::mem::transmute(forceWbPdsRst) };
            forceWbPdsRst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let forceUsbPdsRst: u32 = unsafe { ::core::mem::transmute(forceUsbPdsRst) };
            forceUsbPdsRst as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let forceMcuMemStby: u32 = unsafe { ::core::mem::transmute(forceMcuMemStby) };
            forceMcuMemStby as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let forceDspMemStby: u32 = unsafe { ::core::mem::transmute(forceDspMemStby) };
            forceDspMemStby as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let forceWbMemStby: u32 = unsafe { ::core::mem::transmute(forceWbMemStby) };
            forceWbMemStby as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let forceUsbMemStby: u32 = unsafe { ::core::mem::transmute(forceUsbMemStby) };
            forceUsbMemStby as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let forceMcuGateClk: u32 = unsafe { ::core::mem::transmute(forceMcuGateClk) };
            forceMcuGateClk as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let forceDspGateClk: u32 = unsafe { ::core::mem::transmute(forceDspGateClk) };
            forceDspGateClk as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let forceWbGateClk: u32 = unsafe { ::core::mem::transmute(forceWbGateClk) };
            forceWbGateClk as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let forceUsbGateClk: u32 = unsafe { ::core::mem::transmute(forceUsbGateClk) };
            forceUsbGateClk as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let rsv20_31: u32 = unsafe { ::core::mem::transmute(rsv20_31) };
            rsv20_31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "  @brief PDS force configuration type definition"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PDS_CTL3_Type {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PDS_CTL3_Type() {
    assert_eq!(
        ::core::mem::size_of::<PDS_CTL3_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PDS_CTL3_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PDS_CTL3_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PDS_CTL3_Type))
    );
}
impl PDS_CTL3_Type {
    #[inline]
    pub fn rsv0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsv0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forceMiscPwrOff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceMiscPwrOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv2_3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rsv2_3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn forceMiscIsoEn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceMiscIsoEn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv5_6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rsv5_6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn forceMiscPdsRst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceMiscPdsRst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv8_9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rsv8_9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn forceMiscMemStby(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceMiscMemStby(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv11_12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rsv11_12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn forceMiscGateClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forceMiscGateClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv14_25(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_rsv14_25(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn DspIsoEn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DspIsoEn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv27_28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rsv27_28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn UsbIsoEn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UsbIsoEn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MiscIsoEn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MiscIsoEn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsv31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rsv0: u32,
        forceMiscPwrOff: u32,
        rsv2_3: u32,
        forceMiscIsoEn: u32,
        rsv5_6: u32,
        forceMiscPdsRst: u32,
        rsv8_9: u32,
        forceMiscMemStby: u32,
        rsv11_12: u32,
        forceMiscGateClk: u32,
        rsv14_25: u32,
        DspIsoEn: u32,
        rsv27_28: u32,
        UsbIsoEn: u32,
        MiscIsoEn: u32,
        rsv31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rsv0: u32 = unsafe { ::core::mem::transmute(rsv0) };
            rsv0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let forceMiscPwrOff: u32 = unsafe { ::core::mem::transmute(forceMiscPwrOff) };
            forceMiscPwrOff as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let rsv2_3: u32 = unsafe { ::core::mem::transmute(rsv2_3) };
            rsv2_3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let forceMiscIsoEn: u32 = unsafe { ::core::mem::transmute(forceMiscIsoEn) };
            forceMiscIsoEn as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let rsv5_6: u32 = unsafe { ::core::mem::transmute(rsv5_6) };
            rsv5_6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let forceMiscPdsRst: u32 = unsafe { ::core::mem::transmute(forceMiscPdsRst) };
            forceMiscPdsRst as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let rsv8_9: u32 = unsafe { ::core::mem::transmute(rsv8_9) };
            rsv8_9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let forceMiscMemStby: u32 = unsafe { ::core::mem::transmute(forceMiscMemStby) };
            forceMiscMemStby as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let rsv11_12: u32 = unsafe { ::core::mem::transmute(rsv11_12) };
            rsv11_12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let forceMiscGateClk: u32 = unsafe { ::core::mem::transmute(forceMiscGateClk) };
            forceMiscGateClk as u64
        });
        __bindgen_bitfield_unit.set(14usize, 12u8, {
            let rsv14_25: u32 = unsafe { ::core::mem::transmute(rsv14_25) };
            rsv14_25 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let DspIsoEn: u32 = unsafe { ::core::mem::transmute(DspIsoEn) };
            DspIsoEn as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let rsv27_28: u32 = unsafe { ::core::mem::transmute(rsv27_28) };
            rsv27_28 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let UsbIsoEn: u32 = unsafe { ::core::mem::transmute(UsbIsoEn) };
            UsbIsoEn as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let MiscIsoEn: u32 = unsafe { ::core::mem::transmute(MiscIsoEn) };
            MiscIsoEn as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rsv31: u32 = unsafe { ::core::mem::transmute(rsv31) };
            rsv31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "  @brief PDS force configuration type definition"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PDS_CTL5_Type {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PDS_CTL5_Type() {
    assert_eq!(
        ::core::mem::size_of::<PDS_CTL5_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PDS_CTL5_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PDS_CTL5_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PDS_CTL5_Type))
    );
}
impl PDS_CTL5_Type {
    #[inline]
    pub fn McuWfiMask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_McuWfiMask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsv1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DspWfiMask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DspWfiMask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsv3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LpWfiMask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LpWfiMask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv5_7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rsv5_7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ctrlUsb33(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctrlUsb33(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pdLdo18io(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pdLdo18io(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv10_15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_rsv10_15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn gpioKeepEn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_gpioKeepEn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv19_31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_rsv19_31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        McuWfiMask: u32,
        rsv1: u32,
        DspWfiMask: u32,
        rsv3: u32,
        LpWfiMask: u32,
        rsv5_7: u32,
        ctrlUsb33: u32,
        pdLdo18io: u32,
        rsv10_15: u32,
        gpioKeepEn: u32,
        rsv19_31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let McuWfiMask: u32 = unsafe { ::core::mem::transmute(McuWfiMask) };
            McuWfiMask as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rsv1: u32 = unsafe { ::core::mem::transmute(rsv1) };
            rsv1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DspWfiMask: u32 = unsafe { ::core::mem::transmute(DspWfiMask) };
            DspWfiMask as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rsv3: u32 = unsafe { ::core::mem::transmute(rsv3) };
            rsv3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let LpWfiMask: u32 = unsafe { ::core::mem::transmute(LpWfiMask) };
            LpWfiMask as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let rsv5_7: u32 = unsafe { ::core::mem::transmute(rsv5_7) };
            rsv5_7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ctrlUsb33: u32 = unsafe { ::core::mem::transmute(ctrlUsb33) };
            ctrlUsb33 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let pdLdo18io: u32 = unsafe { ::core::mem::transmute(pdLdo18io) };
            pdLdo18io as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let rsv10_15: u32 = unsafe { ::core::mem::transmute(rsv10_15) };
            rsv10_15 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let gpioKeepEn: u32 = unsafe { ::core::mem::transmute(gpioKeepEn) };
            gpioKeepEn as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let rsv19_31: u32 = unsafe { ::core::mem::transmute(rsv19_31) };
            rsv19_31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "  @brief PDS default level configuration type definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PDS_DEFAULT_LV_CFG_Type {
    #[doc = "< PDS_CTL configuration"]
    pub pdsCtl: PDS_CTL_Type,
    #[doc = "< PDS_CTL2 configuration"]
    pub pdsCtl2: PDS_CTL2_Type,
    #[doc = "< PDS_CTL3 configuration"]
    pub pdsCtl3: PDS_CTL3_Type,
    #[doc = "< PDS_CTL4 configuration"]
    pub pdsCtl4: PDS_CTL4_Type,
    #[doc = "< PDS_CTL5 configuration"]
    pub pdsCtl5: PDS_CTL5_Type,
}
#[test]
fn bindgen_test_layout_PDS_DEFAULT_LV_CFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PDS_DEFAULT_LV_CFG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PDS_DEFAULT_LV_CFG_Type>(),
        20usize,
        concat!("Size of: ", stringify!(PDS_DEFAULT_LV_CFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PDS_DEFAULT_LV_CFG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PDS_DEFAULT_LV_CFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdsCtl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_DEFAULT_LV_CFG_Type),
            "::",
            stringify!(pdsCtl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdsCtl2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_DEFAULT_LV_CFG_Type),
            "::",
            stringify!(pdsCtl2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdsCtl3) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_DEFAULT_LV_CFG_Type),
            "::",
            stringify!(pdsCtl3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdsCtl4) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_DEFAULT_LV_CFG_Type),
            "::",
            stringify!(pdsCtl4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdsCtl5) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_DEFAULT_LV_CFG_Type),
            "::",
            stringify!(pdsCtl5)
        )
    );
}
#[doc = "  @brief PDS control RAM1 type definition"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PDS_CTRL_RAM1_Type {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PDS_CTRL_RAM1_Type() {
    assert_eq!(
        ::core::mem::size_of::<PDS_CTRL_RAM1_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PDS_CTRL_RAM1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PDS_CTRL_RAM1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PDS_CTRL_RAM1_Type))
    );
}
impl PDS_CTRL_RAM1_Type {
    #[inline]
    pub fn ocramSlp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ocramSlp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ocramRet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ocramRet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ramClkCnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_ramClkCnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv14_15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rsv14_15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ramClkCnt2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_ramClkCnt2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv22_23(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rsv22_23(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mcuRamClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mcuRamClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dspRamClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dspRamClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wbRamClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wbRamClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn usbRamClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_usbRamClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn miscRamClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_miscRamClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv29(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsv29(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ctlRamClk2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctlRamClk2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ctlRamClk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctlRamClk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ocramSlp: u32,
        ocramRet: u32,
        ramClkCnt: u32,
        rsv14_15: u32,
        ramClkCnt2: u32,
        rsv22_23: u32,
        mcuRamClk: u32,
        dspRamClk: u32,
        wbRamClk: u32,
        usbRamClk: u32,
        miscRamClk: u32,
        rsv29: u32,
        ctlRamClk2: u32,
        ctlRamClk: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ocramSlp: u32 = unsafe { ::core::mem::transmute(ocramSlp) };
            ocramSlp as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ocramRet: u32 = unsafe { ::core::mem::transmute(ocramRet) };
            ocramRet as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let ramClkCnt: u32 = unsafe { ::core::mem::transmute(ramClkCnt) };
            ramClkCnt as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let rsv14_15: u32 = unsafe { ::core::mem::transmute(rsv14_15) };
            rsv14_15 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 6u8, {
            let ramClkCnt2: u32 = unsafe { ::core::mem::transmute(ramClkCnt2) };
            ramClkCnt2 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let rsv22_23: u32 = unsafe { ::core::mem::transmute(rsv22_23) };
            rsv22_23 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let mcuRamClk: u32 = unsafe { ::core::mem::transmute(mcuRamClk) };
            mcuRamClk as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let dspRamClk: u32 = unsafe { ::core::mem::transmute(dspRamClk) };
            dspRamClk as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let wbRamClk: u32 = unsafe { ::core::mem::transmute(wbRamClk) };
            wbRamClk as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let usbRamClk: u32 = unsafe { ::core::mem::transmute(usbRamClk) };
            usbRamClk as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let miscRamClk: u32 = unsafe { ::core::mem::transmute(miscRamClk) };
            miscRamClk as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let rsv29: u32 = unsafe { ::core::mem::transmute(rsv29) };
            rsv29 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ctlRamClk2: u32 = unsafe { ::core::mem::transmute(ctlRamClk2) };
            ctlRamClk2 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ctlRamClk: u32 = unsafe { ::core::mem::transmute(ctlRamClk) };
            ctlRamClk as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "  @brief PDS control RAM2 type definition"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PDS_CTRL_RAM2_Type {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PDS_CTRL_RAM2_Type() {
    assert_eq!(
        ::core::mem::size_of::<PDS_CTRL_RAM2_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PDS_CTRL_RAM2_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PDS_CTRL_RAM2_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PDS_CTRL_RAM2_Type))
    );
}
impl PDS_CTRL_RAM2_Type {
    #[inline]
    pub fn wramSlp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_wramSlp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn wramRet(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_wramRet(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn rsv20_31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_rsv20_31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wramSlp: u32,
        wramRet: u32,
        rsv20_31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let wramSlp: u32 = unsafe { ::core::mem::transmute(wramSlp) };
            wramSlp as u64
        });
        __bindgen_bitfield_unit.set(10usize, 10u8, {
            let wramRet: u32 = unsafe { ::core::mem::transmute(wramRet) };
            wramRet as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let rsv20_31: u32 = unsafe { ::core::mem::transmute(rsv20_31) };
            rsv20_31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "  @brief PDS OCRAM configuration type definition"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PDS_OCRAM_CFG_Type {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PDS_OCRAM_CFG_Type() {
    assert_eq!(
        ::core::mem::size_of::<PDS_OCRAM_CFG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PDS_OCRAM_CFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PDS_OCRAM_CFG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PDS_OCRAM_CFG_Type))
    );
}
impl PDS_OCRAM_CFG_Type {
    #[inline]
    pub fn PDS_OCRAM_CFG_0KB_16KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_OCRAM_CFG_0KB_16KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_OCRAM_CFG_16KB_32KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_OCRAM_CFG_16KB_32KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_OCRAM_CFG_32KB_48KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_OCRAM_CFG_32KB_48KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_OCRAM_CFG_48KB_64KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_OCRAM_CFG_48KB_64KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_OCRAM_CFG_0KB_16KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_OCRAM_CFG_0KB_16KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_OCRAM_CFG_16KB_32KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_OCRAM_CFG_16KB_32KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_OCRAM_CFG_32KB_48KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_OCRAM_CFG_32KB_48KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_OCRAM_CFG_48KB_64KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_OCRAM_CFG_48KB_64KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_OCRAM_CFG_RSV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_OCRAM_CFG_RSV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PDS_OCRAM_CFG_0KB_16KB_CPU_RAM_SLP: u32,
        PDS_OCRAM_CFG_16KB_32KB_CPU_RAM_SLP: u32,
        PDS_OCRAM_CFG_32KB_48KB_CPU_RAM_SLP: u32,
        PDS_OCRAM_CFG_48KB_64KB_CPU_RAM_SLP: u32,
        PDS_OCRAM_CFG_0KB_16KB_CPU_RAM_RET: u32,
        PDS_OCRAM_CFG_16KB_32KB_CPU_RAM_RET: u32,
        PDS_OCRAM_CFG_32KB_48KB_CPU_RAM_RET: u32,
        PDS_OCRAM_CFG_48KB_64KB_CPU_RAM_RET: u32,
        PDS_OCRAM_CFG_RSV: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PDS_OCRAM_CFG_0KB_16KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_OCRAM_CFG_0KB_16KB_CPU_RAM_SLP) };
            PDS_OCRAM_CFG_0KB_16KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PDS_OCRAM_CFG_16KB_32KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_OCRAM_CFG_16KB_32KB_CPU_RAM_SLP) };
            PDS_OCRAM_CFG_16KB_32KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PDS_OCRAM_CFG_32KB_48KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_OCRAM_CFG_32KB_48KB_CPU_RAM_SLP) };
            PDS_OCRAM_CFG_32KB_48KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PDS_OCRAM_CFG_48KB_64KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_OCRAM_CFG_48KB_64KB_CPU_RAM_SLP) };
            PDS_OCRAM_CFG_48KB_64KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PDS_OCRAM_CFG_0KB_16KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_OCRAM_CFG_0KB_16KB_CPU_RAM_RET) };
            PDS_OCRAM_CFG_0KB_16KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PDS_OCRAM_CFG_16KB_32KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_OCRAM_CFG_16KB_32KB_CPU_RAM_RET) };
            PDS_OCRAM_CFG_16KB_32KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PDS_OCRAM_CFG_32KB_48KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_OCRAM_CFG_32KB_48KB_CPU_RAM_RET) };
            PDS_OCRAM_CFG_32KB_48KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PDS_OCRAM_CFG_48KB_64KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_OCRAM_CFG_48KB_64KB_CPU_RAM_RET) };
            PDS_OCRAM_CFG_48KB_64KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let PDS_OCRAM_CFG_RSV: u32 = unsafe { ::core::mem::transmute(PDS_OCRAM_CFG_RSV) };
            PDS_OCRAM_CFG_RSV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "  @brief PDS WRAM configuration type definition"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PDS_WRAM_CFG_Type {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
#[test]
fn bindgen_test_layout_PDS_WRAM_CFG_Type() {
    assert_eq!(
        ::core::mem::size_of::<PDS_WRAM_CFG_Type>(),
        8usize,
        concat!("Size of: ", stringify!(PDS_WRAM_CFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PDS_WRAM_CFG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PDS_WRAM_CFG_Type))
    );
}
impl PDS_WRAM_CFG_Type {
    #[inline]
    pub fn PDS_WRAM_CFG_0KB_16KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_0KB_16KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_16KB_32KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_16KB_32KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_32KB_48KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_32KB_48KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_48KB_64KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_48KB_64KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_64KB_80KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_64KB_80KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_80KB_96KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_80KB_96KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_96KB_112KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_96KB_112KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_112KB_128KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_112KB_128KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_128KB_144KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_128KB_144KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_144KB_160KB_CPU_RAM_SLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_144KB_160KB_CPU_RAM_SLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_0KB_16KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_0KB_16KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_16KB_32KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_16KB_32KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_32KB_48KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_32KB_48KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_48KB_64KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_48KB_64KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_64KB_80KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_64KB_80KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_80KB_96KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_80KB_96KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_96KB_112KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_96KB_112KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_112KB_128KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_112KB_128KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_128KB_144KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_128KB_144KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_144KB_160KB_CPU_RAM_RET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_144KB_160KB_CPU_RAM_RET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PDS_WRAM_CFG_RSV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_PDS_WRAM_CFG_RSV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PDS_WRAM_CFG_0KB_16KB_CPU_RAM_SLP: u32,
        PDS_WRAM_CFG_16KB_32KB_CPU_RAM_SLP: u32,
        PDS_WRAM_CFG_32KB_48KB_CPU_RAM_SLP: u32,
        PDS_WRAM_CFG_48KB_64KB_CPU_RAM_SLP: u32,
        PDS_WRAM_CFG_64KB_80KB_CPU_RAM_SLP: u32,
        PDS_WRAM_CFG_80KB_96KB_CPU_RAM_SLP: u32,
        PDS_WRAM_CFG_96KB_112KB_CPU_RAM_SLP: u32,
        PDS_WRAM_CFG_112KB_128KB_CPU_RAM_SLP: u32,
        PDS_WRAM_CFG_128KB_144KB_CPU_RAM_SLP: u32,
        PDS_WRAM_CFG_144KB_160KB_CPU_RAM_SLP: u32,
        PDS_WRAM_CFG_0KB_16KB_CPU_RAM_RET: u32,
        PDS_WRAM_CFG_16KB_32KB_CPU_RAM_RET: u32,
        PDS_WRAM_CFG_32KB_48KB_CPU_RAM_RET: u32,
        PDS_WRAM_CFG_48KB_64KB_CPU_RAM_RET: u32,
        PDS_WRAM_CFG_64KB_80KB_CPU_RAM_RET: u32,
        PDS_WRAM_CFG_80KB_96KB_CPU_RAM_RET: u32,
        PDS_WRAM_CFG_96KB_112KB_CPU_RAM_RET: u32,
        PDS_WRAM_CFG_112KB_128KB_CPU_RAM_RET: u32,
        PDS_WRAM_CFG_128KB_144KB_CPU_RAM_RET: u32,
        PDS_WRAM_CFG_144KB_160KB_CPU_RAM_RET: u32,
        PDS_WRAM_CFG_RSV: u32,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PDS_WRAM_CFG_0KB_16KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_0KB_16KB_CPU_RAM_SLP) };
            PDS_WRAM_CFG_0KB_16KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PDS_WRAM_CFG_16KB_32KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_16KB_32KB_CPU_RAM_SLP) };
            PDS_WRAM_CFG_16KB_32KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PDS_WRAM_CFG_32KB_48KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_32KB_48KB_CPU_RAM_SLP) };
            PDS_WRAM_CFG_32KB_48KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PDS_WRAM_CFG_48KB_64KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_48KB_64KB_CPU_RAM_SLP) };
            PDS_WRAM_CFG_48KB_64KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PDS_WRAM_CFG_64KB_80KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_64KB_80KB_CPU_RAM_SLP) };
            PDS_WRAM_CFG_64KB_80KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PDS_WRAM_CFG_80KB_96KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_80KB_96KB_CPU_RAM_SLP) };
            PDS_WRAM_CFG_80KB_96KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PDS_WRAM_CFG_96KB_112KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_96KB_112KB_CPU_RAM_SLP) };
            PDS_WRAM_CFG_96KB_112KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PDS_WRAM_CFG_112KB_128KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_112KB_128KB_CPU_RAM_SLP) };
            PDS_WRAM_CFG_112KB_128KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let PDS_WRAM_CFG_128KB_144KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_128KB_144KB_CPU_RAM_SLP) };
            PDS_WRAM_CFG_128KB_144KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let PDS_WRAM_CFG_144KB_160KB_CPU_RAM_SLP: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_144KB_160KB_CPU_RAM_SLP) };
            PDS_WRAM_CFG_144KB_160KB_CPU_RAM_SLP as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PDS_WRAM_CFG_0KB_16KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_0KB_16KB_CPU_RAM_RET) };
            PDS_WRAM_CFG_0KB_16KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PDS_WRAM_CFG_16KB_32KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_16KB_32KB_CPU_RAM_RET) };
            PDS_WRAM_CFG_16KB_32KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PDS_WRAM_CFG_32KB_48KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_32KB_48KB_CPU_RAM_RET) };
            PDS_WRAM_CFG_32KB_48KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let PDS_WRAM_CFG_48KB_64KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_48KB_64KB_CPU_RAM_RET) };
            PDS_WRAM_CFG_48KB_64KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let PDS_WRAM_CFG_64KB_80KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_64KB_80KB_CPU_RAM_RET) };
            PDS_WRAM_CFG_64KB_80KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PDS_WRAM_CFG_80KB_96KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_80KB_96KB_CPU_RAM_RET) };
            PDS_WRAM_CFG_80KB_96KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let PDS_WRAM_CFG_96KB_112KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_96KB_112KB_CPU_RAM_RET) };
            PDS_WRAM_CFG_96KB_112KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let PDS_WRAM_CFG_112KB_128KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_112KB_128KB_CPU_RAM_RET) };
            PDS_WRAM_CFG_112KB_128KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let PDS_WRAM_CFG_128KB_144KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_128KB_144KB_CPU_RAM_RET) };
            PDS_WRAM_CFG_128KB_144KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let PDS_WRAM_CFG_144KB_160KB_CPU_RAM_RET: u32 =
                unsafe { ::core::mem::transmute(PDS_WRAM_CFG_144KB_160KB_CPU_RAM_RET) };
            PDS_WRAM_CFG_144KB_160KB_CPU_RAM_RET as u64
        });
        __bindgen_bitfield_unit.set(32usize, 22u8, {
            let PDS_WRAM_CFG_RSV: u32 = unsafe { ::core::mem::transmute(PDS_WRAM_CFG_RSV) };
            PDS_WRAM_CFG_RSV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(u32)]
#[doc = "  @brief PDS level 0/1/2/3 mode HBN GPIO interrupt trigger type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PDS_AON_GPIO_INT_Trigger_Type {
    #[doc = "< PDS level 0/1/2/3 mode HBN GPIO INT trigger type: sync falling edge trigger"]
    PDS_AON_GPIO_INT_TRIGGER_SYNC_FALLING_EDGE = 0,
    #[doc = "< PDS level 0/1/2/3 mode HBN GPIO INT trigger type: sync rising edge trigger"]
    PDS_AON_GPIO_INT_TRIGGER_SYNC_RISING_EDGE = 1,
    #[doc = "< PDS level 0/1/2/3 mode HBN GPIO INT trigger type: sync low level trigger"]
    PDS_AON_GPIO_INT_TRIGGER_SYNC_LOW_LEVEL = 2,
    #[doc = "< PDS level 0/1/2/3 mode HBN GPIO INT trigger type: sync high level trigger"]
    PDS_AON_GPIO_INT_TRIGGER_SYNC_HIGH_LEVEL = 3,
    #[doc = "< PDS level 0/1/2/3 mode HBN GPIO INT trigger type: sync rising+falling edge trigger"]
    PDS_AON_GPIO_INT_TRIGGER_SYNC_RISING_FALLING = 7,
    #[doc = "< PDS level 0/1/2/3 mode HBN GPIO INT trigger type: async falling edge trigger"]
    PDS_AON_GPIO_INT_TRIGGER_ASYNC_FALLING_EDGE = 8,
    #[doc = "< PDS level 0/1/2/3 mode HBN GPIO INT trigger type: async rising edge trigger"]
    PDS_AON_GPIO_INT_TRIGGER_ASYNC_RISING_EDGE = 9,
    #[doc = "< PDS level 0/1/2/3 mode HBN GPIO INT trigger type: async low level trigger"]
    PDS_AON_GPIO_INT_TRIGGER_ASYNC_LOW_LEVEL = 10,
    #[doc = "< PDS level 0/1/2/3 mode HBN GPIO INT trigger type: async high level trigger"]
    PDS_AON_GPIO_INT_TRIGGER_ASYNC_HIGH_LEVEL = 11,
}
#[doc = "  @brief PDS APP configuration type definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PDS_APP_CFG_Type {
    #[doc = "< PDS level"]
    pub pdsLevel: u8,
    #[doc = "< Wheather turn off RF"]
    pub turnOffRF: u8,
    #[doc = "< Wheather use xtal 32K as 32K clock source,otherwise use rc32k"]
    pub useXtal32k: u8,
    #[doc = "< PDS level 0/1/2/3 mode always on GPIO Wakeup source(HBN wakeup pin)"]
    pub pdsAonGpioWakeupSrc: u8,
    #[doc = "< PDS level 0/1/2/3 mode always on GPIO Triger type(HBN wakeup pin)"]
    pub pdsAonGpioTrigType: PDS_AON_GPIO_INT_Trigger_Type,
    #[doc = "< Whether power down flash"]
    pub powerDownFlash: u8,
    #[doc = "< Whether turn off embedded flash pad"]
    pub turnOffFlashPad: u8,
    #[doc = "< Whether OCRAM Retention"]
    pub ocramRetetion: u8,
    #[doc = "< Whether trun off PLL"]
    pub turnoffPLL: u8,
    #[doc = "< XTal type, used when user choose turn off PLL, PDS will turn on when exit PDS mode"]
    pub xtalType: u8,
    #[doc = "< Whether enable flash continue read"]
    pub flashContRead: u8,
    #[doc = "< PDS sleep time"]
    pub sleepTime: u32,
    #[doc = "< Flash config pointer, used when power down flash"]
    pub flashCfg: *mut SPI_Flash_Cfg_Type,
    #[doc = "< LDO level"]
    pub ldoLevel: PDS_LDO_LEVEL_Type,
    #[doc = "< Pre callback function"]
    pub preCbFun: ::core::option::Option<unsafe extern "C" fn()>,
    #[doc = "< Post callback function"]
    pub postCbFun: ::core::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_PDS_APP_CFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PDS_APP_CFG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PDS_APP_CFG_Type>(),
        36usize,
        concat!("Size of: ", stringify!(PDS_APP_CFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PDS_APP_CFG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PDS_APP_CFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdsLevel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(pdsLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).turnOffRF) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(turnOffRF)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).useXtal32k) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(useXtal32k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdsAonGpioWakeupSrc) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(pdsAonGpioWakeupSrc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdsAonGpioTrigType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(pdsAonGpioTrigType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).powerDownFlash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(powerDownFlash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).turnOffFlashPad) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(turnOffFlashPad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ocramRetetion) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(ocramRetetion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).turnoffPLL) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(turnoffPLL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xtalType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(xtalType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flashContRead) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(flashContRead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sleepTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(sleepTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flashCfg) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(flashCfg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ldoLevel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(ldoLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).preCbFun) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(preCbFun)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).postCbFun) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PDS_APP_CFG_Type),
            "::",
            stringify!(postCbFun)
        )
    );
}
