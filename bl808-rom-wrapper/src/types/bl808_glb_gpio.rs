/* automatically generated by rust-bindgen 0.63.0 */

pub const NULL: u32 = 0;
#[repr(u32)]
#[doc = " @brief Error type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BL_Err_Type {
    SUCCESS = 0,
    ERROR = 1,
    TIMEOUT = 2,
    INVALID = 3,
    NORESC = 4,
}
#[repr(u32)]
#[doc = " @brief Functional type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BL_Fun_Type {
    DISABLE = 0,
    ENABLE = 1,
}
#[repr(u32)]
#[doc = " @brief Status type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BL_Sts_Type {
    RESET = 0,
    SET = 1,
}
#[repr(u32)]
#[doc = " @brief Mask type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BL_Mask_Type {
    UNMASK = 0,
    MASK = 1,
}
#[repr(u32)]
#[doc = " @brief Logical status Type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LogicalStatus {
    LOGIC_LO = 0,
    LOGIC_HI = 1,
}
#[repr(u32)]
#[doc = " @brief Active status Type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ActiveStatus {
    DEACTIVE = 0,
    ACTIVE = 1,
}
#[doc = "  @brief Interrupt callback function type"]
pub type intCallback_Type = ::core::option::Option<unsafe extern "C" fn()>;
pub type pFunc = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn arch_memcpy(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        n: u32,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn arch_memset(s: *mut ::core::ffi::c_void, c: u8, n: u32) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn arch_memcmp(
        s1: *const ::core::ffi::c_void,
        s2: *const ::core::ffi::c_void,
        n: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arch_memcpy4(dst: *mut u32, src: *const u32, n: u32) -> *mut u32;
}
extern "C" {
    pub fn arch_memcpy_fast(
        pdst: *mut ::core::ffi::c_void,
        psrc: *const ::core::ffi::c_void,
        n: u32,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn arch_memset4(dst: *mut u32, val: u32, n: u32) -> *mut u32;
}
extern "C" {
    pub fn memcopy_to_fifo(fifo_addr: *mut ::core::ffi::c_void, data: *mut u8, length: u32);
}
extern "C" {
    pub fn fifocopy_to_mem(fifo_addr: *mut ::core::ffi::c_void, data: *mut u8, length: u32);
}
extern "C" {
    pub fn arch_ctzll(val: *mut u64, bit: *mut u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arch_clzll(val: *mut u64, bit: *mut u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arch_ffsll(val: *mut u64, bit: *mut u32) -> ::core::ffi::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GLB_GPIO_Type {
    GLB_GPIO_PIN_0 = 0,
    GLB_GPIO_PIN_1 = 1,
    GLB_GPIO_PIN_2 = 2,
    GLB_GPIO_PIN_3 = 3,
    GLB_GPIO_PIN_4 = 4,
    GLB_GPIO_PIN_5 = 5,
    GLB_GPIO_PIN_6 = 6,
    GLB_GPIO_PIN_7 = 7,
    GLB_GPIO_PIN_8 = 8,
    GLB_GPIO_PIN_9 = 9,
    GLB_GPIO_PIN_10 = 10,
    GLB_GPIO_PIN_11 = 11,
    GLB_GPIO_PIN_12 = 12,
    GLB_GPIO_PIN_13 = 13,
    GLB_GPIO_PIN_14 = 14,
    GLB_GPIO_PIN_15 = 15,
    GLB_GPIO_PIN_16 = 16,
    GLB_GPIO_PIN_17 = 17,
    GLB_GPIO_PIN_18 = 18,
    GLB_GPIO_PIN_19 = 19,
    GLB_GPIO_PIN_20 = 20,
    GLB_GPIO_PIN_21 = 21,
    GLB_GPIO_PIN_22 = 22,
    GLB_GPIO_PIN_23 = 23,
    GLB_GPIO_PIN_24 = 24,
    GLB_GPIO_PIN_25 = 25,
    GLB_GPIO_PIN_26 = 26,
    GLB_GPIO_PIN_27 = 27,
    GLB_GPIO_PIN_28 = 28,
    GLB_GPIO_PIN_29 = 29,
    GLB_GPIO_PIN_30 = 30,
    GLB_GPIO_PIN_31 = 31,
    GLB_GPIO_PIN_32 = 32,
    GLB_GPIO_PIN_33 = 33,
    GLB_GPIO_PIN_34 = 34,
    GLB_GPIO_PIN_35 = 35,
    GLB_GPIO_PIN_36 = 36,
    GLB_GPIO_PIN_37 = 37,
    GLB_GPIO_PIN_38 = 38,
    GLB_GPIO_PIN_39 = 39,
    GLB_GPIO_PIN_40 = 40,
    GLB_GPIO_PIN_41 = 41,
    GLB_GPIO_PIN_42 = 42,
    GLB_GPIO_PIN_43 = 43,
    GLB_GPIO_PIN_44 = 44,
    GLB_GPIO_PIN_45 = 45,
    GLB_GPIO_PIN_46 = 46,
    GLB_GPIO_PIN_47 = 47,
    GLB_GPIO_PIN_48 = 48,
    GLB_GPIO_PIN_49 = 49,
    GLB_GPIO_PIN_50 = 50,
    GLB_GPIO_PIN_51 = 51,
    GLB_GPIO_PIN_MAX = 52,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GLB_GPIO_FUNC_Type {
    GPIO_FUN_SDH = 0,
    GPIO_FUN_SPI0 = 1,
    GPIO_FUN_FLASH = 2,
    GPIO_FUN_I2S = 3,
    GPIO_FUN_PDM = 4,
    GPIO_FUN_I2C0 = 5,
    GPIO_FUN_I2C1 = 6,
    GPIO_FUN_UART = 7,
    GPIO_FUN_ETHER_MAC = 8,
    GPIO_FUN_CAM = 9,
    GPIO_FUN_ANALOG = 10,
    GPIO_FUN_GPIO = 11,
    GPIO_FUN_PWM0 = 16,
    GPIO_FUN_PWM1 = 17,
    GPIO_FUN_SPI1 = 18,
    GPIO_FUN_I2C2 = 19,
    GPIO_FUN_I2C3 = 20,
    GPIO_FUN_MM_UART = 21,
    GPIO_FUN_DBI_B = 22,
    GPIO_FUN_DBI_C = 23,
    GPIO_FUN_DPI = 24,
    GPIO_FUN_JTAG_LP = 25,
    GPIO_FUN_JTAG_M0 = 26,
    GPIO_FUN_JTAG_D0 = 27,
    GPIO_FUN_CLOCK_OUT = 31,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLB_GPIO_Cfg_Type {
    pub gpioPin: u8,
    pub gpioFun: u8,
    pub gpioMode: u8,
    pub pullType: u8,
    pub drive: u8,
    pub smtCtrl: u8,
    pub outputMode: u8,
}
#[test]
fn bindgen_test_layout_GLB_GPIO_Cfg_Type() {
    const UNINIT: ::core::mem::MaybeUninit<GLB_GPIO_Cfg_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GLB_GPIO_Cfg_Type>(),
        7usize,
        concat!("Size of: ", stringify!(GLB_GPIO_Cfg_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<GLB_GPIO_Cfg_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(GLB_GPIO_Cfg_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpioPin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_Cfg_Type),
            "::",
            stringify!(gpioPin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpioFun) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_Cfg_Type),
            "::",
            stringify!(gpioFun)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpioMode) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_Cfg_Type),
            "::",
            stringify!(gpioMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pullType) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_Cfg_Type),
            "::",
            stringify!(pullType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drive) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_Cfg_Type),
            "::",
            stringify!(drive)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).smtCtrl) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_Cfg_Type),
            "::",
            stringify!(smtCtrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outputMode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_Cfg_Type),
            "::",
            stringify!(outputMode)
        )
    );
}
#[repr(u32)]
#[doc = "  @brief GLB GPIO interrupt control mode type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GLB_GPIO_INT_TRIG_Type {
    #[doc = "< GPIO interrupt sync mode, GPIO falling edge trigger interrupt"]
    GLB_GPIO_INT_TRIG_SYNC_FALLING_EDGE = 0,
    #[doc = "< GPIO interrupt sync mode, GPIO rising edge trigger interrupt"]
    GLB_GPIO_INT_TRIG_SYNC_RISING_EDGE = 1,
    #[doc = "< GPIO interrupt sync mode, GPIO low level trigger interrupt (32k 3T)"]
    GLB_GPIO_INT_TRIG_SYNC_LOW_LEVEL = 2,
    #[doc = "< GPIO interrupt sync mode, GPIO high level trigger interrupt (32k 3T)"]
    GLB_GPIO_INT_TRIG_SYNC_HIGH_LEVEL = 3,
    #[doc = "< GPIO interrupt sync mode, GPIO falling and rising edge trigger interrupt"]
    GLB_GPIO_INT_TRIG_SYNC_FALLING_RISING_EDGE = 4,
    #[doc = "< GPIO interrupt async mode, GPIO falling edge trigger interrupt"]
    GLB_GPIO_INT_TRIG_ASYNC_FALLING_EDGE = 8,
    #[doc = "< GPIO interrupt async mode, GPIO rising edge trigger interrupt"]
    GLB_GPIO_INT_TRIG_ASYNC_RISING_EDGE = 9,
    #[doc = "< GPIO interrupt async mode, GPIO low level trigger interrupt (32k 3T)"]
    GLB_GPIO_INT_TRIG_ASYNC_LOW_LEVEL = 10,
    #[doc = "< GPIO interrupt async mode, GPIO high level trigger interrupt (32k 3T)"]
    GLB_GPIO_INT_TRIG_ASYNC_HIGH_LEVEL = 11,
}
#[repr(u32)]
#[doc = "  @brief GLB GPIO FIFO interrupt type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GLB_GPIO_FIFO_INT_Type {
    #[doc = "< GLB GPIO FIFO Underflow or Overflow interrupt"]
    GLB_GPIO_FIFO_INT_FER = 0,
    #[doc = "< GLB GPIO FIFO ready (tx_fifo_cnt > tx_fifo_th) interrupt"]
    GLB_GPIO_FIFO_INT_FIFO = 1,
    #[doc = "< GLB GPIO FIFO Empty interrupt"]
    GLB_GPIO_FIFO_INT_END = 2,
    #[doc = "< All the interrupt"]
    GLB_GPIO_FIFO_INT_ALL = 3,
}
#[repr(u32)]
#[doc = "  @brief GLB GPIO FIFO Timing Phase type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GLB_GPIO_FIFO_PHASE_Type {
    #[doc = "< GPIO first send high level"]
    GPIO_FIFO_PHASE_FIRST_HIGH = 0,
    #[doc = "< GPIO first send low level"]
    GPIO_FIFO_PHASE_FIRST_LOW = 1,
}
#[repr(u32)]
#[doc = "  @brief GLB GPIO FIFO Idle State type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GLB_GPIO_FIFO_IDLE_Type {
    GPIO_FIFO_IDLE_LOW = 0,
    GPIO_FIFO_IDLE_HIGH = 1,
}
#[repr(u32)]
#[doc = "  @brief GLB GPIO FIFO Latch Mode type definition"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GLB_GPIO_FIFO_LATCH_Type {
    #[doc = "< GPIO FIFO direct write I/O"]
    GPIO_FIFO_LATCH_WRITE = 0,
    #[doc = "< GPIO FIFO set/clr I/O"]
    GPIO_FIFO_LATCH_SETCLEAR = 1,
}
#[doc = "  @brief GPIO interrupt configuration structure type definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLB_GPIO_INT_Cfg_Type {
    #[doc = "< GPIO pin num"]
    pub gpioPin: GLB_GPIO_Type,
    #[doc = "< GPIO interrupt trig mode"]
    pub trig: GLB_GPIO_INT_TRIG_Type,
    #[doc = "< GPIO interrupt mask config"]
    pub intMask: BL_Mask_Type,
}
#[test]
fn bindgen_test_layout_GLB_GPIO_INT_Cfg_Type() {
    const UNINIT: ::core::mem::MaybeUninit<GLB_GPIO_INT_Cfg_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GLB_GPIO_INT_Cfg_Type>(),
        12usize,
        concat!("Size of: ", stringify!(GLB_GPIO_INT_Cfg_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<GLB_GPIO_INT_Cfg_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(GLB_GPIO_INT_Cfg_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpioPin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_INT_Cfg_Type),
            "::",
            stringify!(gpioPin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trig) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_INT_Cfg_Type),
            "::",
            stringify!(trig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intMask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_INT_Cfg_Type),
            "::",
            stringify!(intMask)
        )
    );
}
#[doc = "  @brief UART configuration structure type definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLB_GPIO_FIFO_CFG_Type {
    #[doc = "< The clock num of code0 first send"]
    pub code0FirstTime: u8,
    #[doc = "< The clock num of code1 first send"]
    pub code1FirstTime: u8,
    #[doc = "< The total clock num of code0/1(high + low"]
    pub codeTotalTime: u16,
    #[doc = "< low or high level of code0 first send"]
    pub code0Phase: GLB_GPIO_FIFO_PHASE_Type,
    #[doc = "< low or high level of code1 first send"]
    pub code1Phase: GLB_GPIO_FIFO_PHASE_Type,
    #[doc = "< the I/O idle level"]
    pub idle: GLB_GPIO_FIFO_IDLE_Type,
    #[doc = "< FIFO threshold"]
    pub fifoDmaThreshold: u8,
    #[doc = "< Enable or disable DMA of GPIO"]
    pub fifoDmaEnable: BL_Fun_Type,
    #[doc = "< Write or set/clr GPIO level"]
    pub latch: GLB_GPIO_FIFO_LATCH_Type,
}
#[test]
fn bindgen_test_layout_GLB_GPIO_FIFO_CFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<GLB_GPIO_FIFO_CFG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GLB_GPIO_FIFO_CFG_Type>(),
        28usize,
        concat!("Size of: ", stringify!(GLB_GPIO_FIFO_CFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<GLB_GPIO_FIFO_CFG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(GLB_GPIO_FIFO_CFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code0FirstTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_FIFO_CFG_Type),
            "::",
            stringify!(code0FirstTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code1FirstTime) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_FIFO_CFG_Type),
            "::",
            stringify!(code1FirstTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).codeTotalTime) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_FIFO_CFG_Type),
            "::",
            stringify!(codeTotalTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code0Phase) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_FIFO_CFG_Type),
            "::",
            stringify!(code0Phase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code1Phase) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_FIFO_CFG_Type),
            "::",
            stringify!(code1Phase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idle) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_FIFO_CFG_Type),
            "::",
            stringify!(idle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fifoDmaThreshold) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_FIFO_CFG_Type),
            "::",
            stringify!(fifoDmaThreshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fifoDmaEnable) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_FIFO_CFG_Type),
            "::",
            stringify!(fifoDmaEnable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).latch) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GLB_GPIO_FIFO_CFG_Type),
            "::",
            stringify!(latch)
        )
    );
}
